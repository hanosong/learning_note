### 虚拟节点

1. 虚拟节点是什么
   -1:是一个纯对象,是对真实节点的描述

2. 虚拟节点的作用
   -1:用来提升性能,更高效的实现 DOM 操作,更新视图
   -2:如果使用真实节点,所有的操作都是操作真实节点(jq:无节制的使用 DOM 操作)

3. 虚拟节点有三个最基本的属性

```js
<div>111</div>;
//上面的div的虚拟节点如何描述?
const vnode = {
  tag: "div",
  attrs: [
    {
      id: "app",
    },
  ],
  children: ["1111"],
};
```

### diff 算法

1. 为什么用 diff 算法
   -1:虚拟节点是如何高效的帮助我们实现视图更新的?

2. <div id="app"> <p>pppp</p> </div> =>这个的虚拟节点

```js
const vnode = {
  tag: "div",
  attrs: [{ id: "app" }],
  children: [
    {
      tag: "p",
      attrs: [],                => 这里是标签内的样式类名
      children: ["pppp"],
    },
  ],
};
```

3. 真实节点的操作 vs 虚拟节点的操作

```js
//真实节点的操作
const oP = document.querySelector("div > p");
oP.innerHTML = "dddd";

//虚拟节点的操作
vnode.children[0].children[0] = "dddd";
```

4. 虚拟节点和真实节点修改视图总结
   => Vue 更新视图时,会先更新与视图对应的虚拟节点
   => 虚拟节点更新后,Vue 会根据 diff 算法,采用一种最高效的方式去更新视图

### diff 算法详解

1. diff 算法考虑的是什么问题?
   => 视图更新时,如何实现最小代价更新真实节点?

2. diff 算法是如何比较更新前后的虚拟节点?
   => 同级比较

3. 当比较出结果后,如何更新组件? -法 1: 原地更新 (标签不删除,不新增,不移动位置) -法 2: 替换更新 (可能会删除,新增,移动位置)

4. 同级比较后
   => 如果更新前后是同一个标签,则使用原地更新策略
   => 如果更新前后是不同的标签,则使用替换更新

5. 如何知道更新前后是不是同一个标签? 必须同时满足
   -1: 更新前后的标签名一致
   -2: 更新前后的 key 一致,如果没有写 key 属性,则默认 key 一致
